
lombok.RequiredArgsConstructor
框架
swagger
mybatis-plus
hutool工具包
org.springframework.data.redis.core.RedisTemplate#opsForHash
异步生成兑换码
流式编程 java.util.stream.Stream#collect(java.util.stream.Collector<? super T,A,R>)
cn.hutool.core.bean.BeanUtil
 线程池策略
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy
java 11 新特性
java.util.stream.Collectors#groupingBy(java.util.function.Function<? super T,? extends K>, java.util.stream.Collector<? super T,A,D>)
执行lua脚本
org.springframework.data.redis.core.RedisTemplate#execute(org.springframework.data.redis.core.script.RedisScript<T>, java.util.List<K>, java.lang.Object...)


兑换码的需求
- 可读性好：兑换码是要给用户使用的，用户需要输入兑换码，因此可读性必须好。我们的要求：
  - 长度不超过10个字符
  - 只能是24个大写字母和8个数字：ABCDEFGHJKLMNPQRSTUVWXYZ23456789
- 数据量大：优惠活动比较频繁，必须有充足的兑换码，最好有10亿以上的量
- 唯一性：10亿兑换码都必须唯一，不能重复，否则会出现兑换混乱的情况
- 不可重兑：兑换码必须便于校验兑换状态，避免重复兑换
- 防止爆刷：兑换码的规律性不能很明显，不能轻易被人猜测到其它兑换码
- 高效：兑换码生成、验证的算法必须保证效率，避免对数据库带来较大的压力

Base32转码 自增id
BitMap 重兑校验 
JWT技术 防刷校验
线程池异步生成兑换码

XXL-JOB的数据分片


接口说明 领取发放中的优惠券
请求方式 POST
请求路径 /user-coupons/{id}/receive
请求参数 路径占位符，优惠券id
返回值 无

优惠券一系列的校验：
- 校验优惠券是否存在，不存在无法领取
- 校验优惠券的发放时间，是不是正在发放中
- 校验优惠券剩余库存是否充足
- 校验优惠券的每人限领数量

只有全部校验通过，才可以领取优惠券，而领券要做两件事：
- 新增一个记录到user_coupon表
- 更新coupon表中已经领取的数量


兑换码是否兑换则要利用BitMap
乐观锁解决超卖
UPDATE coupon SET issue_num = issue_num + 1 WHERE id = 1 AND issue_num < total_num





锁对象
并且同步代码块的锁指定为用户id，那么同一个用户并发操作时会被锁定，不同用户互相没有影响
先开启事务(可重复读)，再获取锁 ---> 锁失效
事务失效问题 
由于Spring的事务是基于AOP的方式结合动态代理来实现的。因此事务方法一定要是public的，这样才能便于被Spring做事务的代理和增强。
事务传播行为不对 默认事务传播行为（spring默认传播行为,支持当前事务，如果当前没有事务，则新建一个事务）+ REQUIRES_NEW


1）引入AspectJ依赖：
AspectJ
<!--aspecj-->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
2）暴露代理对象
在启动类上添加注解，暴露代理对象
@EnableAspectJAutoProxy(exposeProxy = true)

3）使用代理对象
IUserCouponService userCouponService = (IUserCouponService） AopContext.currentProxy();
userCouponService.checkAndcreateUserCoupon(coupon,userId,null);


分布式锁问题
锁误删、超时释放
锁的重入问题、失败重试、一致性
解决方案
- 原子性问题：可以利用Redis的LUA脚本来编写锁操作，确保原子性
- 超时问题：利用WatchDog（看门狗）机制，获取锁成功时开启一个定时任务，在锁到期前自动续期，避免超时释放。而当服务宕机后，WatchDog跟着停止运行，不会导致死锁。
- 锁重入问题：可以模拟Synchronized原理，放弃setnx，而是利用Redis的Hash结构来记录锁的持有者以及重入次数，获取锁时重入次数+1，释放锁是重入次数-1，次数为0则锁删除
- 主从一致性问题：可以利用Redis官网推荐的RedLock机制来解决


Redisson
基于AOP的思想，将业务部分作为切入点，将业务前后的锁操作作为环绕增强。



@Component
@Aspect
@RequiredArgsConstructor
public class MyLockAspect implements Ordered {

    private final MyLockFactory lockFactory;

    @Around("@annotation(myLock)")
    public Object tryLock(ProceedingJoinPoint pjp, MyLock myLock) throws Throwable {
        // 1.创建锁对象
        RLock lock = lockFactory.getLock(myLock.lockType(), myLock.name());
        // 2.尝试获取锁
        boolean isLock = myLock.lockStrategy().tryLock(lock, myLock);
        // 3.判断是否成功
        if(!isLock) {
            // 3.1.失败，快速结束
            return null;
        }
        try {
            // 3.2.成功，执行业务
            return pjp.proceed();
        } finally {
            // 4.释放锁
            lock.unlock();
        }
    }

    @Override
    public int getOrder() {
        return 0;
    }
}

@Component
public class MyLockFactory {

    private final Map<MyLockType, Function<String, RLock>> lockHandlers;

    public MyLockFactory(RedissonClient redissonClient) {
        this.lockHandlers = new EnumMap<>(MyLockType.class);
        this.lockHandlers.put(RE_ENTRANT_LOCK, redissonClient::getLock);
        this.lockHandlers.put(FAIR_LOCK, redissonClient::getFairLock);
        this.lockHandlers.put(READ_LOCK, name -> redissonClient.getReadWriteLock(name).readLock());
        this.lockHandlers.put(WRITE_LOCK, name -> redissonClient.getReadWriteLock(name).writeLock());
    }

    public RLock getLock(MyLockType lockType, String name){
        return lockHandlers.get(lockType).apply(name);
    }
}


public enum MyLockStrategy {
    SKIP_FAST(){
        @Override
        public boolean tryLock(RLock lock, MyLock prop) throws InterruptedException {
            return lock.tryLock(0, prop.leaseTime(), prop.unit());
        }
    },
    FAIL_FAST(){
        @Override
        public boolean tryLock(RLock lock, MyLock prop) throws InterruptedException {
            boolean isLock = lock.tryLock(0, prop.leaseTime(), prop.unit());
            if (!isLock) {
                throw new BizIllegalException("请求太频繁");
            }
            return true;
        }
    },
    KEEP_TRYING(){
        @Override
        public boolean tryLock(RLock lock, MyLock prop) throws InterruptedException {
            lock.lock( prop.leaseTime(), prop.unit());
            return true;
        }
    },
    SKIP_AFTER_RETRY_TIMEOUT(){
        @Override
        public boolean tryLock(RLock lock, MyLock prop) throws InterruptedException {
            return lock.tryLock(prop.waitTime(), prop.leaseTime(), prop.unit());
        }
    },
    FAIL_AFTER_RETRY_TIMEOUT(){
        @Override
        public boolean tryLock(RLock lock, MyLock prop) throws InterruptedException {
            boolean isLock = lock.tryLock(prop.waitTime(), prop.leaseTime(), prop.unit());
            if (!isLock) {
                throw new BizIllegalException("请求太频繁");
            }
            return true;
        }
    },
    ;

    public abstract boolean tryLock(RLock lock, MyLock prop) throws InterruptedException;
}


org.springframework.data.redis.core.RedisTemplate#opsForZSet

缓存 PromotionConstants.COUPON_CACHE_KEY_PREFIX + coupon.getId() 
